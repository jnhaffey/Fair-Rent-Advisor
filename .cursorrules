# Cursor Rules for Fair Rent Advisor

## Project Context
This is an AI-driven SaaS project using .NET 8 backend (Azure Functions) and React TypeScript frontend. The development process follows an agent-based workflow where Claude agents generate implementation prompts for Cursor AI to execute.

## General Principles

### Code Quality
- Write clean, readable, and maintainable code
- Follow SOLID principles and clean architecture patterns
- Prefer composition over inheritance
- Use meaningful variable and method names
- Add comments only when necessary to explain "why", not "what"
- Keep functions and classes focused on single responsibilities

### Testing
- Write unit tests for all business logic
- Aim for high test coverage (80%+)
- Use descriptive test names that explain the scenario
- Follow Arrange-Act-Assert pattern in tests
- Mock external dependencies appropriately

### Error Handling
- Use proper exception handling with specific exception types
- Log errors with appropriate context and severity levels
- Provide meaningful error messages to users
- Handle edge cases gracefully

## .NET Backend Rules

### Project Structure
- Follow Clean Architecture: Core (domain) → Infrastructure → API
- Use dependency injection for all services
- Implement repository pattern for data access
- Separate concerns between controllers, services, and repositories

### Coding Standards
- Use C# 12 language features appropriately
- Follow Microsoft C# coding conventions
- Use nullable reference types consistently
- Implement async/await patterns for I/O operations
- Use record types for DTOs and value objects
- Use primary constructors where appropriate

### Azure Functions Specific
- Use isolated worker model (not in-process)
- Keep functions thin - delegate to services
- Use proper binding attributes
- Implement proper logging with ILogger
- Handle dependency injection in Program.cs

### API Design
- Follow RESTful conventions
- Use appropriate HTTP status codes
- Implement proper request/response models
- Add input validation using FluentValidation or Data Annotations
- Use consistent naming conventions (camelCase for JSON)

### Example Function Structure:
```csharp
[Function("GetRentAnalysis")]
public async Task<HttpResponseData> GetRentAnalysis(
    [HttpTrigger(AuthorizationLevel.Function, "get", Route = "rent-analysis/{id}")] HttpRequestData req,
    string id)
{
    // Delegate to service, handle errors, return proper response
}
```

## React Frontend Rules

### Project Structure
- Use feature-based folder structure
- Separate components, hooks, services, and types
- Keep components focused and reusable
- Use barrel exports (index.ts) for cleaner imports

### Component Standards
- Use functional components with hooks
- Implement proper TypeScript interfaces for props
- Use React.memo() for performance optimization when needed
- Keep components under 200 lines when possible
- Extract custom hooks for reusable logic

### TypeScript Standards
- Use strict TypeScript configuration
- Define proper interfaces for all data structures
- Use union types and enums appropriately
- Avoid 'any' type - use proper typing
- Use generic types for reusable components

### State Management
- Use React hooks (useState, useReducer) for local state
- Consider Context API for shared state
- Implement proper error boundaries
- Use React Query/TanStack Query for server state

### Styling
- Use CSS modules or styled-components for component styling
- Follow BEM methodology if using plain CSS
- Implement responsive design principles
- Use CSS custom properties for theming

### Example Component Structure:
```typescript
interface RentAnalysisProps {
  propertyId: string;
  onAnalysisComplete?: (result: RentAnalysis) => void;
}

export const RentAnalysisComponent: React.FC<RentAnalysisProps> = ({ 
  propertyId, 
  onAnalysisComplete 
}) => {
  // Component implementation
};
```

## Development Workflow

### Git Practices
- Use conventional commit messages (feat:, fix:, docs:, etc.)
- Keep commits focused and atomic
- Write descriptive commit messages
- Use feature branches for development

### Code Reviews
- All code should be reviewed before merging
- Use the Code Review Agent for AI-assisted reviews
- Check for security vulnerabilities
- Verify test coverage and quality

### Documentation
- Update README.md for significant changes
- Document API endpoints with proper examples
- Keep architectural decisions recorded
- Update changelog for releases

## Security Guidelines

### General Security
- Never commit secrets, API keys, or passwords
- Use environment variables for configuration
- Implement proper input validation and sanitization
- Use HTTPS for all communications

### .NET Security
- Use parameterized queries to prevent SQL injection
- Implement proper authentication and authorization
- Use secure cookie settings
- Validate and sanitize all user inputs

### React Security
- Sanitize user inputs to prevent XSS
- Use secure HTTP headers
- Implement proper CORS policies
- Avoid dangerouslySetInnerHTML unless absolutely necessary

## Performance Guidelines

### .NET Performance
- Use async/await for I/O operations
- Implement proper caching strategies
- Use efficient LINQ queries
- Profile and optimize database queries
- Use appropriate data structures

### React Performance
- Use React.memo() for expensive components
- Implement proper key props in lists
- Avoid unnecessary re-renders
- Use code splitting for large applications
- Optimize bundle size

## AI Agent Integration

### Prompt Engineering
- Provide clear, specific requirements to agents
- Include relevant context and constraints
- Specify expected outcomes and success criteria
- Request code examples when helpful

### Code Generation
- Review all AI-generated code thoroughly
- Ensure generated code follows these rules
- Test AI-generated code comprehensively
- Refactor if necessary to meet standards

### Iteration Process
1. Product Manager Agent defines requirements
2. Architecture Agent validates design
3. Software Engineer Agent creates implementation prompts
4. Cursor AI implements code following these rules
5. Code Review Agent validates implementation
6. QA Engineer Agent plans testing approach

## File Naming Conventions

### .NET Files
- Use PascalCase for classes, interfaces, and methods
- Prefix interfaces with 'I' (e.g., IUserService)
- Use descriptive names that indicate purpose
- Group related files in appropriate folders

### React Files
- Use PascalCase for component files (e.g., UserProfile.tsx)
- Use camelCase for utility and service files
- Use kebab-case for CSS files
- Include file type in name when appropriate (e.g., UserProfile.types.ts)

## Dependencies and Packages

### .NET Packages
- Keep packages up to date and secure
- Use official Microsoft packages when available
- Avoid unnecessary dependencies
- Document any non-standard package choices

### npm Packages
- Prefer well-maintained packages with good TypeScript support
- Keep dependencies minimal and focused
- Use exact versions for critical dependencies
- Regular security audits with npm audit

## Environment Configuration

### Development Environment
- Use consistent environment setup across team
- Document required tools and versions
- Use Docker for consistent development environment
- Maintain separate configs for dev/staging/prod

### Configuration Management
- Use strongly-typed configuration classes in .NET
- Use environment variables for sensitive data
- Implement proper configuration validation
- Document all configuration options

## Workflow Automation Rules

### Prompt Documentation
- Every prompt given to Cursor should be saved into the `AI Prompts/` folder
- Use the naming convention: `#-Software Engineer Agent.md` (where # is the next sequential number)
- Include the full prompt text, context, and any relevant details
- This maintains a complete record of the AI-driven development process

### Changelog Management
- Every time changes are committed, update the `docs/changelog.md` file to reflect the changes
- Follow the Keep a Changelog format (https://keepachangelog.com/en/1.0.0/)
- Categorize changes as: Added, Changed, Deprecated, Removed, Fixed, Security
- Include commit hash and date for traceability
- Include a well worded vesion of the commit message
- Move items from [Unreleased] to appropriate version sections when releasing

Remember: These rules should be followed consistently across all AI-generated and manually written code in this project.
